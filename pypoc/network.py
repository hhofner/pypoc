'''
This module contains the core Network class, which collects a list of objects
and creates a NetworkX object representation of the network. The main method of
the Network class loops through all network objects and calls their run() method.

Additionally, the Network class collects and holds a "NetworkData" object, which
contains all the metadata of the Network.
'''

__author__ = 'Hans Hofner'

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import itertools
import networkx as nx
import seaborn as sns
import pandas as pd
import numpy as np
import itertools
import pickle
import os

from copy import copy
from scipy.spatial import distance

import pypoc.topology
import pypoc.signal_tools
from pypoc.node import Packet, Node, VaryingTransmitNode, VaryingRelayNode, MovingNode, RestrictedNode


class Infodata:
    '''
    Contains information about a particular type of
    data being collected.
    '''
    def __init__(data, information):
        self._data = data
        self._information = information


class NetworkData:
    '''
    Contains specific InfoData objects on the Network.
    '''
    def __init__():
        self.throughputs = Infodata([],
            'List of whole network throughput values per time.')
        self.overall_throughput = Infodata(0,
            'The overall throughput of the network')
        self.step_value = Infodata(0,
            'The time it takes for one packet to be sent, in seconds.')
        self.generated_packets = Infodata(0,
            'The number of packets generated by source nodes in the Network')

class PyPocNetwork(nx.Graph):
    def initialize(self, packet_size, **kwargs):
        self.packet_size = packet_size
        self.initialize_step_values()
        self.overall_throughput = 0

        self.data = {'throughputs':[]}
        self.parameters = kwargs

    def initialize_step_values(self):
        '''
        This method defines the step value for the
        network based on bandwidth and packet size.
        '''
        highest_bandwidth = self.find_highest_bandwidth()
        self.step_value = self.packet_size/highest_bandwidth
        for node in self.nodes:
            node.step_value = self.step_value
        input(f'step value: {self.step_value}')

    def find_highest_bandwidth(self):
        highest = None
        for edge in self.edges:
            v, u = edge
            if highest is None:
               highest = self[u][v]['Bandwidth']
            elif self[u][v]['Bandwidth'] < highest:
                highest = self[u][v]['Bandwidth']

        return highest

    def update_byte_count(self, packet):
        try:
            self.total_byte_count += packet.size
        except:
            self.total_byte_count = packet.size

    def update_throughput(self):
        try:
            self.overall_throughput = (self.total_byte_count / (self.tick * self.step_value))
            self.data['throughputs'].append(self.overall_throughput)
        except:
            raise

    def get(self, key, node1, node2):
        return self[node1][node2][str(key)]

    def run_for(self, minutes):
        seconds = minutes * 60
        ticks = seconds / self.step_value
        self.tick = 1
        while self.tick < ticks:
            print(f'\n~~~~ TIME {self.tick} ~~~~\n')
            for node in self.nodes:
                print(f'---->: {node} :<----')
                node.run(self)
            self.tick += 1

            self.update_channel_loads()
            self.update_channel_links()

        print(f'########### FINISH ###########')
        print(f'\tGENERATED PACKETS: {Packet.generated_count}')
        print(f'\tARRIVED PACKETS: {Packet.arrived_count}')
        print(f'\tDROPPED PACKETS: {Packet.dropped_count}')
        print(f'\tPACKET LOSS RATE: {Packet.dropped_count/Packet.generated_count}')
        print(f'\tOVERALL THROUGHPUT: {self.overall_throughput/1e3} KBps')
        self.packet_drop_rate = (Packet.dropped_count / Packet.generated_count) * 100

    def reset(self):
        Packet.reset()

    def get_count_of(self, type_of_node):
        count = 0
        for node in self.nodes:
            if node.type == type_of_node:
                count += 1
        return count

    def update_channel_loads(self):
        for edge in self.edges:
            n1, n2 = edge
            self[n1][n2]['Channel'] = len(n1.queue) + len(n2.queue)

    def update_channel_links(self):
        for node in self.nodes:
            if node.is_moving:
                print(f'Updating links for {node}')
                ''' Find distance between all other nodes'''
                to_remove_edges = []
                for edge in self.edges(node):
                    n1, n2 = edge
                    dist = distance.euclidean(n1.position, n2.position)
                    # input(f'Distance: {dist}\n\tn1 position: {n1.position}\n\tn2 position: {n2.position}')
                    ''' Then calculate the capacity for that link'''
                    capacity = signal_tools.calculate_capacity(dist)/8 # in BYTES
                    # input(f'Calculated Capacity: {capacity}')
                    '''Then Change the capacity'''
                    # self[n1][n2]['Bandwidth'] = capacity
                    # self.initialize_step_values()
                    if capacity < self.parameters['threshold_value']:
                        to_remove_edges.append((n1, n2))

                for node_pair in to_remove_edges:
                    u, v = node_pair
                    self.remove_edge(u, v)

    def run_network(self, minutes, edge_structure, packet_size, **kwargs):
        '''
        :param minutes: Number of minutes to run the simulation for.
        :param edge_structure: list of edge tuples with bandwidth definition.
        :param packet_size: packet sizes to be sent.
        :param **kwargs: any other key-word arguments.
        :return: None

        '''
        self.add_edges_from(edge_structure)
        self.initialize(packet_size, **kwargs)
        self.run_for(minutes)
